on:
  push:
    paths:
      - "hosts"  # Se ejecuta solo cuando se modifica el archivo principal
  workflow_dispatch:  # Permite ejecutarlo manualmente desde GitHub Actions

jobs:
  update-hosts:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar el repositorio
        uses: actions/checkout@v4

      - name: Ejecutar el script de sincronizaci√≥n
        run: |
          cat << 'EOF' > update_hosts.sh
          #!/bin/bash
          set -e
          MAIN_HOSTS="hosts"
          
          # Buscar archivos que comiencen con "US"
          CUSTOM_FILES=( $(find . -maxdepth 1 -type f -name "US*") )
          
          if [ ${#CUSTOM_FILES[@]} -eq 0 ]; then
              echo "No se encontraron archivos US*, saliendo..."
              exit 0
          fi
          
          # Funci√≥n para actualizar el archivo personalizado en base al archivo principal.
          update_custom() {
              local custom_file="$1"
              local tmp_file
              tmp_file=$(mktemp)
          
              # Leer l√≠neas del archivo principal y del personalizado en arrays.
              mapfile -t main_lines < "$MAIN_HOSTS"
              mapfile -t custom_lines < "$custom_file"
          
              # Si el archivo personalizado tiene una cabecera de personalizaci√≥n, se conserva.
              local header=""
              if [[ ${custom_lines[0]} =~ ^[[:space:]]*#\ Personalizaci√≥n\ espec√≠fica\ para\ .* ]]; then
                  header="${custom_lines[0]}"
                  custom_lines=("${custom_lines[@]:1}")
              fi
          
              # Crear un array asociativo con las l√≠neas comentadas del personalizado (sin el s√≠mbolo "#").
              declare -A commented_lines
              for line in "${custom_lines[@]}"; do
                  if [[ "$line" =~ ^[[:space:]]*# ]]; then
                      # Remover el s√≠mbolo '#' y recortar espacios en blanco a ambos lados.
                      trimmed="${line#\#}"
                      trimmed="$(echo -e "$trimmed" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
                      if [ -n "$trimmed" ]; then
                          commented_lines["$trimmed"]=1
                      fi
                  fi
              done
          
              # Determinar el n√∫mero m√°ximo de l√≠neas a procesar (para preservar el orden)
              local n_main=${#main_lines[@]}
              local n_custom=${#custom_lines[@]}
              local max=$n_main
              if [ $n_custom -gt $max ]; then
                  max=$n_custom
              fi
          
              new_lines=()
              # Incluir la cabecera si existe.
              if [ -n "$header" ]; then
                  new_lines+=("$header")
              fi
          
              # Procesar l√≠nea por l√≠nea
              for (( i=0; i<max; i++ )); do
                  local main_line=""
                  local custom_line=""
                  if [ $i -lt $n_main ]; then
                      main_line="${main_lines[i]}"
                  fi
                  if [ $i -lt $n_custom ]; then
                      custom_line="${custom_lines[i]}"
                  fi
          
                  if [ -n "$main_line" ]; then
                      # Si en el personalizado no existe la l√≠nea en ese rengl√≥n‚Ä¶
                      if [ -z "$custom_line" ]; then
                          # Verificar si la l√≠nea ya existe en forma comentada.
                          if [[ ${commented_lines["$main_line"]+exists} ]]; then
                              # Se considera duplicada, no se a√±ade.
                              new_lines+=("")
                          else
                              new_lines+=("$main_line")
                          fi
                      else
                          # Si ya existe una l√≠nea en el personalizado:
                          # Si est√° comentada, se conserva sin cambios.
                          if [[ "$custom_line" =~ ^[[:space:]]*# ]]; then
                              new_lines+=("$custom_line")
                          else
                              # Si no est√° comentada y difiere de la principal, se actualiza.
                              if [ "$custom_line" != "$main_line" ]; then
                                  new_lines+=("$main_line")
                              else
                                  new_lines+=("$custom_line")
                              fi
                          fi
                      fi
                  else
                      # Si no hay l√≠nea en el archivo principal pero s√≠ en el personalizado, se conserva.
                      if [ -n "$custom_line" ]; then
                          new_lines+=("$custom_line")
                      fi
                  fi
              done
          
              # Escribir el resultado en el archivo temporal y reemplazar el archivo personalizado.
              printf "%s\n" "${new_lines[@]}" > "$tmp_file"
              mv "$tmp_file" "$custom_file"
          }
          
          # Procesar cada archivo US*
          for CUSTOM_FILE in "${CUSTOM_FILES[@]}"; do
              if [ ! -f "$CUSTOM_FILE" ]; then
                  # Si a√∫n no existe, se crea copiando el archivo principal y agregando una cabecera.
                  cp "$MAIN_HOSTS" "$CUSTOM_FILE"
                  sed -i "1s/^/# Personalizaci√≥n espec√≠fica para $CUSTOM_FILE\n/" "$CUSTOM_FILE"
              else
                  update_custom "$CUSTOM_FILE"
              fi
          done
          EOF
          
          chmod +x update_hosts.sh
          ./update_hosts.sh
          
      - name: Subir cambios si hay modificaciones
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions@github.com"
          
          git add .
          if git diff --cached --quiet; then
            echo "No hay cambios en los archivos US*, saliendo..."
            exit 0
          fi
          
          git commit -m "üöÄ Actualizaci√≥n autom√°tica de archivos hosts personalizados"
          git push
